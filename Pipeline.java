//Import all needed files
import java.awt.image.BufferedImage;
import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import javax.imageio.ImageIO;
import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JLabel;

import org.opencv.core.*;
import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.*;

/**
* Pipeline class.
* 
* <P>Autogenerated pipeline from GRIP. 
*
* <P>Make sure to set all sources using the setters before running processImage().
*
* <P>Tutorials and examples can be found online
*  
* @author GRIP
*/
public class Pipeline{
	
	//This map links the Outputs with their names
	protected Map<String,Object> outputs;
	protected Mat source0;
	
	/**
	 * This constructor sets up the pipeline
	 */
	public Pipeline(){
		outputs = new HashMap<String,Object>();
	}
	
	/**
	 * This is the primary method that runs the entire pipeline and updates the outputs.
	 */
	protected void processImage(){
		//Step0: CV resize: 
		//inputs
		Mat Input0 = source0;
		Size dsize0 = new Size(0,0);
		double fx0 = 0.25;
		double fy0 = 0.25;
		int interpolation0 = Imgproc.INTER_LINEAR;

		//output
		Mat step0Output0 = new Mat();
		//operation
		Imgproc.resize(Input0,step0Output0,dsize0,fx0,fy0,interpolation0);
		outputs.put("step0Output0", step0Output0); 

		//Step1: HSV Threshold: 
		//inputs
		Mat input1 = step0Output0;
		double hueL1 = 35.611510791366904;
		double hueH1 = 86.7911714770798;
		double satL1 = 32.10431654676259;
		double satH1 = 255.0;
		double valL1 = 38.98381294964029;
		double valH1 = 255.0;
		//output
		Mat step1Output0 = new Mat();
		//operation
		Imgproc.cvtColor(input1, step1Output0, Imgproc.COLOR_BGR2HSV);
		Core.inRange(step1Output0, new Scalar(hueL1, satL1 ,valL1), new Scalar(hueH1, satH1 ,valH1), step1Output0);
		outputs.put("step1Output0", step1Output0); 


		//Step2: CV dilate: 
		//inputs
		Mat input2 =  step1Output0;
		Mat kernel2 = new Mat();
		Point anchor2 = new Point(-1,-1);
		int iterations2 = (int)0.0;
		int borderType2 = Core.BORDER_CONSTANT;
		Scalar borderValue2 = new Scalar(-1);
		//output
		Mat step2Output0 = new Mat();
		//operation
		Imgproc.dilate(input2,step2Output0,kernel2,anchor2,iterations2,borderType2,borderValue2);
		outputs.put("step2Output0", step2Output0); 

		//Step3: Find Contours: 
		//inputs
		Mat input3 = step2Output0;
		Mat hierarchy3 = new Mat();
		int mode3 = Imgproc.RETR_LIST;
		int method3 = Imgproc.CHAIN_APPROX_SIMPLE;
		//output
		List<MatOfPoint> step3Output0 = new ArrayList<MatOfPoint>();
		//operation
		Imgproc.findContours(input3, step3Output0, hierarchy3, mode3, method3);
		outputs.put("step3Output0", step3Output0); 

		//Step4: Filter Contours: 
		//inputs
		List<MatOfPoint> inputContours4 = step3Output0;
		double minArea4 = 300.0;
		double minPerimeter4 = 0;
		double minWidth4 = 0;
		double maxWidth4 = 1000;
		double minHeight4 = 0;
		double maxHeight4 = 1000;
		double minSolidity4 = 0;
		double maxSolidity4 = 100;
		double minVertexCount4 = 0;
		double maxVertexCount4 = 1000000;
		double minRatio4 = 0;
		double maxRatio4 = 1000;
		//output
		List<MatOfPoint> step4Output0 = new ArrayList<MatOfPoint>();
		//operation
		filterContours(inputContours4, step4Output0 , minArea4, minPerimeter4, minWidth4, maxWidth4, minHeight4, maxHeight4, minSolidity4, 
			maxSolidity4, minVertexCount4, maxVertexCount4, minRatio4, maxRatio4);
		outputs.put("step4Output0", step4Output0); 

	}

	/**
	 * This method sets source 0. 
	 * @param source is the Mat that the source will be set to 
	 */
	public void setSource0(Mat source){
		this.source0 = source;
	}


	/**
	 * This method is a generated getter for the output of a CV resize.
	 * @return Mat is the output.
	 */
	public Mat getstep0Output0(){
		return (Mat) outputs.get("step0Output0");
	}
	/**
	 * This method is a generated getter for the output of a HSV Threshold.
	 * @return Mat is the output.
	 */
	public Mat getstep1Output0(){
		return (Mat) outputs.get("step1Output0");
	}
	/**
	 * This method is a generated getter for the output of a CV dilate.
	 * @return Mat is the output.
	 */
	public Mat getstep2Output0(){
		return (Mat) outputs.get("step2Output0");
	}
	/**
	 * This method is a generated getter for the output of a Find Contours.
	 * @return List<MatOfPoint> is the output.
	 */
	public List<MatOfPoint> getstep3Output0(){
		return (List<MatOfPoint>) outputs.get("step3Output0");
	}
	/**
	 * This method is a generated getter for the output of a Filter Contours.
	 * @return List<MatOfPoint> is the output.
	 */
	public List<MatOfPoint> getstep4Output0(){
		return (List<MatOfPoint>) outputs.get("step4Output0");
	}
	
			
	/**
	 * Takes contours and places them on a image
	 * @param out is Color Mat that the contours will be placed on
	 * @param contours is a list of contours to be displayed
	 * @return the out mat with contours on it
	 */
	public static Mat showContours(Mat out, List<MatOfPoint> contours) {
		Imgproc.drawContours(out,contours, -1, new Scalar(0, 255, 0));
		return out;
	}	
		
	/**
	 * Filters through contours.
	 * @param inputContours is the input list of contours
	 * @param output is the the output list of contours
	 * @param minArea is the minimum area of a contour that will be kept
	 * @param minPerimeter is the minimum perimeter of a contour that will be kept
	 * @param minWidth minimum width of a contour
	 * @param maxWidth maximum width 
	 * @param minHeight minimum height
	 * @param maxHeight  maximimum height
	 * @param minSolidity the minimum solidity of a contour
	 * @param maxSolidity the maximimum solidity of a contour
	 * @param minVertexCount minimum vertex Count of the contours
	 * @param maxVertexCount maximum vertex Count
	 * @param minRatio minimum ratio of width to height
	 * @param maxRatio maximum ratio of width to height
	 * @return returns a list of filtered contours
	 */
	public static List<MatOfPoint> filterContours(List<MatOfPoint> inputContours, List<MatOfPoint> output, double minArea,
		double minPerimeter, double minWidth, double maxWidth, double minHeight, double maxHeight, double minSolidity, 
		double maxSolidity, double minVertexCount, double maxVertexCount, double minRatio, double maxRatio){
		final MatOfInt hull = new MatOfInt();
		//operation
		for (int i = 0; i < inputContours.size(); i++) {
			final MatOfPoint contour = inputContours.get(i);
		
			final Rect bb = Imgproc.boundingRect(contour);
			if (bb.width < minWidth || bb.width > maxWidth)
				continue;
			if (bb.height < minHeight || bb.height > maxHeight)
				continue;
			
			final double area = Imgproc.contourArea(contour);
			if (area < minArea)
				continue;
			if (Imgproc.arcLength(new MatOfPoint2f(contour.toArray()), true) < minPerimeter)
				continue;
			
			Imgproc.convexHull(contour, hull);
			MatOfPoint mopHull = new MatOfPoint();
			mopHull.create((int) hull.size().height, 1, CvType.CV_32SC2);
			for (int j = 0; j < hull.size().height; j++) {
					int index = (int) hull.get(j, 0)[0];
				double[] point = new double[] { contour.get(index, 0)[0], contour.get(index, 0)[1] };
					mopHull.put(j, 0, point);
			}
			final double solidity = 100 * area / Imgproc.contourArea(mopHull);
			if (solidity < minSolidity || solidity > maxSolidity) continue;
			if (contour.rows() < minVertexCount || contour.rows() > maxVertexCount)	continue;
			final double ratio = bb.width / bb.height;
			if (ratio < minRatio || ratio > maxRatio)	continue;
				output.add(contour);
		}
		return output;
	}		
}
